Design Patterns
	- Conjunto de padrões de codificação, voltados principalmente para o mundo orientado a objetos.
	- Separados em três grupos, como: Criacional(Creational), Estrutural(Structural) e Comportamental(Behavior).
	- Os padrões mais conhecidos são os definidos pela Gangue dos quatros (GoF - Gang of Four).

Padrão Criacional (Creational Pattern)
	- O padrões da categoria criacional (creational) são relacionados a forma como criamos os objetos.
	- Factory Method
		- Neste padrão utilizamos uma abstração para auxiliar na criação de diversas implementações concretas de um mesmo tipo em comum.
		- Por exemplo
			- Uma Classe Celular.
			- Possuí classes filhas. Que são: IPhone, Motorola, Samsung, Xiaomi e Nokia.
			- Uma classe abstrata CelularFactory
			- Possuí um método estático create(): Celular.
			- Possuí um método concreto que chama request(labelCelular: String): Celular.
				- Cria as implementações conforme a labelCelular passada como parametro.
			- Implementações IPhoneFactory, MotorolaFactory, SamsungFactory, XiaomiFactory e NokiaFactory.
			- Todas as classes Factories deverão implementar o método createCelular.
	- Abstract Method
		- Neste padrão utilizamos uma interface para criar familias de objetos relacionados ou dependentes.
		- Enquanto no Factory Method nós criávamos uma fábrica para cada objeto especifico. Neste padrão, críamos para uma cadeia de objetos interligados.
		- Por exemplo
			- Uma interface LectureAbstractFactory.
			- Possuí dois métodos abstratos, chamados: getProperties(): Properties, getAvailableRegion(): AvaliableRegion[].
			- Possuí implementações. Que são: JavaLectureAbstractFactory, DotNetLectureAbstractFactory e KotlinLectureAbstractFactory.
			- Todas classes derivadas de LectureAbstractFactory, devem implementar seus métodos abstratos.
	- Singleton
		- Neste padrão criamos uma classe para gerenciar a criação de instâncias únicas e globais.
		- Por exemplo
			- Uma classe Connection.
			- Possuí um método estático chamado getInstance(): Connection.
			- Possuí um atributo privado e final connection: Connection . Onde sua instancia é criada no momento da sua declaração.
			- O método getInstance(): Connection é o responsável por retornar o atributo connection.
	- Monostate
		- Neste padrão também criamos uma classe para gerenciar a criação de instâncias únicas e globais. Porém com a diferença de que nós não críamos um método estático para retornar um atributo de classe.
		- Este padrão nos dá a possibilidade de trabalhar com a implementação de interfaces.
		- Por exemplo
			- Uma interface PoolEntityManager
			- Possuí um método abstrato chamado getInstance(): PoolEntityManager.
			- Três classes PostgresPoolEntityManager, OraclePoolEntityManager e MySqlPostgresPoolEntityManager.
			- Implementam a interface PoolEntityManager.
			- Possuem uma váriavel estática poolEntitiesManager: EntityManager[].
			- O método getInstance(): PoolEntityManager retorna o EntityManager disponível para uso.
	- Builder
		- Neste padrão conseguimos criar diversas representações de classes diferentes, sem criar sobrecarga de construtores.
		- Temos dois tipos de implementação para este padrão, que são: default, fluente e functional.
		- Por exemplo
			- Uma classe Celular.
				- Possuí atributos privados finais, como: String nome, String modelo, String tipoUsb, String marca, BigDecimal valor, Double taxa.
				- Possuí um construtor que preenche todos os atributos privados.
				- Possuí métodos de acesso getters(): <Tipo> para acessar os tipo finais.
				- Possuí uma classe estática interna Builder.
					- Possuí atributos protecteds, como: String nome, String modelo, String tipoUsb, String marca, BigDecimal valor, Double taxa.
					- Possuí métodos de acesso para atribuição para cada atributo e retorna o próprio Builder (this).
					- Possuí um método build(): Celular que retorna a construção de um celular com os atributos protegidos.
	- Prototype
		- Neste padrão criamos uma cópia de um objeto.
		- Podemos utilizar o método clone(): Object do java declarado na interface Cloneable. Porém, este método faz o clone somente da maneira "shallow copy" e não "deep copy".
		- Por exemplo
			- Uma classe Celular.
			- Possuí atributos privados String nome, String modelo, String tipoUsb, String marca, BigDecimal valor.
			- Implementa Cloneable e sobrescreve o método clone(): Object.

Padrão Estrutural (Structural Pattern)
	- O padrões da categoria estrutural (structural) são relacionados a forma como relacionamos os objetos ou as classes.
	- Adapter
		- Neste padrão criamos um adapter para que duas classes divergentes consigam se comunicar sem qualquer dificuldade.
		- Temos um Padrão Arquitetural chamado Hexagonal que utiliza muito este padrão.
		- Por exemplo
			- Uma interface AmericanConnector.
				- Possui métodos isBiVoltage(): boolean e getVoltage(): String.
			- Uma classe Charger.
				- Possui atributos boolean biVoltage, String voltage.
				- Possui classes filhas AmericanCharger, EuropeanCharger e AsianCharger.
			- Uma classe AmericanCharger.
				- Implementa a interface AmericanConnector.
			- Uma classe EuropeanChargerToAmericanConnectorAdapter.
				- Possui um atributo EuropeanCharger.
					= É recebido como parametro no construtor e assim populado.
				- Implementa a interface AmericanConnector.
			- Uma classe ElectricalOutlet.
				- Possui atributos String voltage e boolean inUse.
				- Possui um método connect(AmericanCharger): void.
	- Bridge
		- Neste padrão conseguimos fazer a comunicação dentre estruturas de dominio diferentes através do conceito de pontes.
		- São criadas abstrações/interfaces. Onde a comunicação é realizada entre elas e não através de classes concretas.
		- Por exemplo
			- Uma interface Service.
				- Possui implementações nas classes PhoneService, SupportService e EmailService.
			- Uma interface Controller.
				- Possui implementações nas classes PhoneController, SupportController e EmailController.
				- Possui um construtor
					- Recebe Service como parametro.
				- Possui métodos que invocam métodos da interface service.
				- Não conhece as implementações concretas da interface Service.
	- Composite
		- Neste padrão conseguimos fazer a utilização da recursividade.
		- São criadas classes que utilizam do conceito parte/todo. Onde temos uma classe abstrata pai e algumas estruturas filhas.
		- As estruturas filhas podem se compor referenciando seu pai.
		- Por exemplo
			- Uma classe abstrata FileSystemItem
				- Possui atributo nameÇ String.
				- Declara o método save(FileSystemItem): boolean.
			- Uma classe FileItem
				- Estende a classe FileSystemItem.
				- Implementa o método save(String): boolean.
					- Salva o nome do arquivo.
			- Uma classe FolderItem
				- Possuì um atributo chamado List<FileSystemItem> child.
				- Estende a classe FileSystemItem.
				- Implementa o método save(String): boolean.
					- Adiciona FileSystemItem a lista de child.
	- Decorator
		- Neste padrão nós conseguimos utilizar uma alternativa a herança. Fazendo com que consigamos incrementar funcionalidades novas sem qualquer problema de forte acoplamento.
		- Por exemplo
			- Uma interface Payment
				- Possui declaração do método transfer(value: BigDecimal, accountSource: AccountBank, accountTarget: AccountBank): boolean
			- Uma classe PIX
				- Implementa a interface Payment e seus métodos
			- Uma classe DOC
				- Implementa a interface Payment e seus métodos
			- Uma classe TED
				- Implementa a interface Payment e seus métodos
			- Uma classe AccountBank
				- Possui atributo account: String, agency: String e owner: String
			- Uma Classe TransferService
				- Possui o método transfer(accountSource: AccountBank, accountTarget: AccountBank, value: BigDecimal): boolean
					- Invoca o executePayment(payment: Payment): boolean
				- Possui o metodo executePayment(payment: Payment): boolean
	- Facade
		- Neste padrão nós conseguimos utilizar uma questão de fachada, ou seja, criamos abstração do que deve ser chamado pelo cliente.
		- Por exemplo
			- Uma interface ServiceFacade
				- Possui declaração do método create(Object: object) boolean
			- Uma classe ServiceFacadeImpl
				- Implementa a interface ServiceFacade.
	- FlyWeight
		- Neste padrão nós conseguimos classificar dados de um objeto como importate e não importante.
		- Extrinseco
			- É o dado que pode ser manipulado externamente, de forma que, ele consiga ser totalmente mutável.
		- Intriseco
			- É o dado que pode ser manipulado internamente, de forma que, ele deve ser imutável.
		- Por exemplo
			- Uma classe PersonFlyWeight
				- Possui atributos imutaveis.
				- idade: Integer
		 		- cpf: String
				- rg: String
			- Uma classe Person
				- Possui atributos mutáveis.
				- nome: String
				- genero: String
				- personFlyweight: PersonFlyWeight
	- Proxy
		- Neste padrão críamos um intermediário de requisições por exemplo Classe1 -> chama -> Proxy -> faz tratativa -> e chama -> Classe2.
		- Tipos
			- Remote, Virtual, Protection e Smart.
		- Por exemplo
			- Uma interface Operations
				- Possui métodos
					- deposit(account: String, value: BigDecimal): boolean
					- transfer(accountSource: String, accountTarget: String, value: BigDecimal): boolean
					- grab(account: String, value: BigDecimal): boolean
			- Uma classe Bank
				- Implementa a interface Operations.
			- Uma classe ATMProxy
				- Possui um atributo bank: Bank
				- Possui um método construtor ATMProxy(bank: Bank): void
				- Implementa Operations.
				- Dentro dos métodos implementados faz as devidas tratativas e delega para o atributo bank as devidas execuções.

Padrão Comportamental (Behavior Pattern)
	- O padrões da categoria comportamental (behavior) são relacionados a forma como críamos as regras de execução do nosso algoritmo.
	- Chain of Responsability
		- 
